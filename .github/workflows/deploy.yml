name: Deploy Python script to EC2

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
          - name: Deploy to EC2 servers (debug & verbose)
        env:
          SSH_USER: ${{ secrets.EC2_SSH_USER }}
          SERVERS_JSON_PATH: "servers.json"
          REMOTE_APP_DIR: "python-app"
          LOCAL_START_SCRIPT: "your_script.py"
        run: |
          SSH_USER="${SSH_USER:-ec2-user}"
          # read IPs
          mapfile -t IPS < <(jq -r '.servers[]' "$SERVERS_JSON_PATH")
          if [ ${#IPS[@]} -eq 0 ]; then
            echo "No IPs found in $SERVERS_JSON_PATH"
            exit 1
          fi

          for ip in "${IPS[@]}"; do
            echo "================== Deploying to $ip =================="
            # create remote dir
            ssh -o StrictHostKeyChecking=no -i ec2_key.pem "${SSH_USER}@${ip}" "mkdir -p ~/${REMOTE_APP_DIR}" || {
              echo "SSH mkdir failed for $ip"
              continue
            }

            # rsync repo contents
            rsync -az --delete --exclude='.git' --exclude='.github' -e "ssh -o StrictHostKeyChecking=no -i ec2_key.pem" ./ "${SSH_USER}@${ip}:~/${REMOTE_APP_DIR}/" || {
              echo "rsync failed for $ip"
              continue
            }

            # Run verbose remote diagnostics + start script.
            # We create a small remote shell script (remote_runner.sh), run it with 'bash -x' and print its output,
            # so the GH Actions log contains the remote trace and any errors.
            ssh -o StrictHostKeyChecking=no -i ec2_key.pem "${SSH_USER}@${ip}" bash -s <<'REMOTE_EOF' 2>&1 | sed "s/^/[${ip}] /"
set -x
set -o pipefail

cd ~/"${REMOTE_APP_DIR}" || { echo "FAILED: cannot cd to ~/${REMOTE_APP_DIR}"; exit 2; }

echo "----- REMOTE: pwd -----"
pwd

echo "----- REMOTE: ls -la -----"
ls -la

echo "----- REMOTE: which python3 -----"
which python3 || true

echo "----- REMOTE: python3 --version -----"
python3 --version || true

echo "----- REMOTE: show head of start script -----"
if [ -f "${LOCAL_START_SCRIPT}" ]; then
  head -n 40 "${LOCAL_START_SCRIPT}" || true
else
  echo "WARNING: ${LOCAL_START_SCRIPT} not found in $(pwd)"
fi

# Dump last 200 lines of previous output.log so we can see prior failures (if any)
if [ -f output.log ]; then
  echo "----- REMOTE: last 200 lines of output.log -----"
  tail -n 200 output.log || true
else
  echo "----- REMOTE: output.log not present (that's OK) -----"
fi

# Create a wrapper script to start the app and capture logs/traces
cat > remote_start_runner.sh <<'SH'
#!/usr/bin/env bash
set -x
set -o pipefail

# optional: record environment
echo "ENV PATH=$PATH"
echo "ENV whoami=$(whoami)"
echo "ENV ulimit -a:"
ulimit -a || true

# best-effort stop previous matching processes - do not fail if pkill missing
if command -v pkill >/dev/null 2>&1; then
  pkill -f "python3 ${LOCAL_START_SCRIPT}" || true
else
  echo "pkill not found; skipping pkill"
fi

# Start script with nohup; redirect stdout/stderr to output.log
nohup python3 "${LOCAL_START_SCRIPT}" > output.log 2>&1 &
sleep 1
# show the newly started background processes matching the script name
ps aux | grep -E "python.*${LOCAL_START_SCRIPT}" | grep -v grep || true

echo "REMOTE START: exit code $?"
SH

# make it executable and run it with bash -x, capture its stdout/stderr
chmod +x remote_start_runner.sh || true
bash -x remote_start_runner.sh || echo "remote_start_runner.sh returned non-zero"

echo "----- REMOTE: tail output.log -----"
if [ -f output.log ]; then
  tail -n 200 output.log || true
else
  echo "No output.log produced by start command"
fi

echo "----- REMOTE: remote_start_runner.sh content -----"
sed -n '1,200p' remote_start_runner.sh || true

REMOTE_EOF

            # show separation in logs
            echo "================== Done $ip =================="
          done
        shell: bash


      - name: Cleanup SSH key
        if: always()
        run: |
          shred -u ec2_key.pem || rm -f ec2_key.pem
        shell: bash
